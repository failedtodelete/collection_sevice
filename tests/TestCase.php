<?php

namespace Tests;

use App\Models\User;
use \Illuminate\Foundation\Testing\TestResponse;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Schema;
use Laravel\Passport\Passport;

abstract class TestCase extends BaseTestCase
{

    use CreatesApplication;

    /**
     * Auth user;
     * @var
     */
    protected $authAdminSeed = false;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->migrate('admin');
        $this->artisan('db:seed --class=AdminRoles');
        $this->artisan('db:seed --class=AdminStatuses');

        $this->migrate('public');
        $this->migrate('temp');

        // Удаление всех свзяей между ролями и разрешениями.
        DB::connection('mysql_admin')->table('permission_role')->truncate();
    }

    /**
     * Отправка запроса на сервер
     * Если в массив $options передать auth = true,
     * запрос пойдет в маркером токена доступа аутентифицированного пользователя.
     * @param $method
     * @param $uri
     * @param array $data
     * @param array $headers
     * @param array $options
     * @return TestResponse
     */
    public function ajax($method, $uri, $data = [], $headers = [], $options = [])
    {
        // Установка необходимых заголовков в запрос.
        $headers['X-Requested-With'] = 'XMLHttpRequest';
        $headers['Accept'] = 'application/json';

        // Внедрение Bearer ключа аутентифицированного пользователя.
        if (key_exists('auth', $options) || key_exists('auth_current', $options)) {
            if (key_exists('auth', $options) && mb_strlen($options['auth'])) $auth = $this->auth($options['auth']);
            else if (key_exists('auth_current', $options) && gettype($options['auth_current']) == 'integer') {
                $auth = $this->auth_current($options['auth_current']);
            }

            // Получение токена пользователя для совершения запроса.
            $token = auth()->guard('api')->login($auth);
            $headers['Authorization'] = 'Bearer ' . $token;
        }

        Log::info($headers);
        return $this->withHeaders($headers)->json($method, $uri, $data);
    }

    /**
     * Удаление, очистка таблиц.
     * Создание и регистрация файла миграции для определенной базы данных.
     * @param $type
     */
    protected function migrate($type)
    {

        // Сброс таблиц базы данных.
        $this->artisan("migrate:reset --database=mysql_${type} --path='database/migrations/${type}'");

        // Удаление таблицы @migrations
        Schema::connection("mysql_{$type}")->dropIfExists('migrations');

        // Создание и регистрация таблицы @migrations
        if (!Schema::hasTable ("mysql_{$type}.migrations")) $this->artisan("migrate:install --database=mysql_${type}");

        // Накатываение миграций.
        $this->artisan("migrate --database='mysql_{$type}' --path='database/migrations/${type}'");
    }

    /**
     * Получение аутентифицированного пользователя.
     * @param $roleOrPermission
     * @return mixed|null
     */
    protected function auth($roleOrPermission)
    {

        // Модель пользователя, созданного через factory.
        $user = null;

        // Использование обратного значения.
        // Еесли первый символ роли или разрешения начинается со знака "!" используется обратное значение.
        $opposite_value = false;
        if ($roleOrPermission[0] == '!') {
            $roleOrPermission = substr($roleOrPermission, '1', strlen($roleOrPermission) - 1);
            $opposite_value = true;
        }

        // Опредение роли или разрешения.
        // Если получен массив из нескольких слов - это разрешение, иначе - роль.
        $arr = explode('.', $roleOrPermission);

        // Удаление всех свзяей между ролями и разрешениями.
        DB::connection('mysql_admin')->table('permission_role')->truncate();

        if (count($arr) > 1) {

            // Получено разрешение.
            // Поиск роли, которое имеет или не имеет текущее разрешение на основе обратного значения.
            $permission = DB::connection('mysql_admin')->table('permissions')->where('name', $roleOrPermission)->first();
            $role = DB::connection('mysql_admin')->table('permissions')->first();
            if (!$opposite_value) {
                DB::connection('mysql_admin')->table('permission_role')->insert(['permission_id' => $permission->id, 'role_id' => $role->id]);
            }

        } else {

            // Получена роль.
            // Получение роли на основе обратного значения.
            if (!$opposite_value) {
                $role = DB::connection('mysql_admin')->table('roles')->where('name', '=', $roleOrPermission)->first();
            } else {
                $role = DB::connection('mysql_admin')->table('roles')->where('name', '!=', $roleOrPermission)->first();
            }

        }

        // Создание пользовалея с текущей ролью.
        $user = factory(User::class)->create(['role_id' => $role->id]);

        return $user;
    }

    /**
     * Получение текущего пользователя.
     * @param $id
     * @return \Illuminate\Database\Query\Builder|mixed
     */
    protected function auth_current($id)
    {
        // Получение пользователя.
        $data = DB::connection('mysql_admin')->table('users')->find($id);
        $user = User::findOrFail($data->id);

        // Аутентификация пользователя для доступа токена.
        Passport::actingAs($user);
        return $user;
    }

}
